---
title: React Hooks 学习笔记
date: 2019/09/21
tags:
  - React
  - Hooks
  - 前端开发
categories:
  - 技术学习
cover: https://images.unsplash.com/photo-1633356122544-f134324a6cee?w=800&h=400&fit=crop
---

# React Hooks 学习笔记

## 什么是 Hooks

Hooks 是 React 16.8 引入的新特性，它允许你在函数组件中使用状态和其他 React 特性，而无需编写类组件。

### 为什么需要 Hooks

1. **简化组件逻辑**：避免在类组件中复杂的生命周期方法
2. **代码复用**：自定义 Hooks 可以在多个组件间共享逻辑
3. **更好的 TypeScript 支持**：函数组件更容易进行类型推导
4. **减少嵌套**：避免高阶组件和渲染属性模式带来的嵌套

## 基础 Hooks

### useState
```javascript
import React, { useState } from 'react';

function Counter() {
  const [count, setCount] = useState(0);
  
  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>
        Increment
      </button>
    </div>
  );
}
```

### useEffect
```javascript
import React, { useState, useEffect } from 'react';

function UserProfile({ userId }) {
  const [user, setUser] = useState(null);
  
  useEffect(() => {
    // 组件挂载后执行
    fetchUser(userId).then(setUser);
    
    // 清理函数
    return () => {
      // 组件卸载前执行清理
    };
  }, [userId]); // 依赖数组
  
  return <div>{user?.name}</div>;
}
```

### useContext
```javascript
import React, { createContext, useContext } from 'react';

const ThemeContext = createContext();

function ThemeProvider({ children }) {
  const [theme, setTheme] = useState('light');
  
  return (
    <ThemeContext.Provider value={{ theme, setTheme }}>
      {children}
    </ThemeContext.Provider>
  );
}

function ThemedButton() {
  const { theme, setTheme } = useContext(ThemeContext);
  
  return (
    <button 
      style={{ background: theme === 'light' ? '#fff' : '#000' }}
      onClick={() => setTheme(theme === 'light' ? 'dark' : 'light')}
    >
      Toggle Theme
    </button>
  );
}
```

## 额外 Hooks

### useReducer
```javascript
import React, { useReducer } from 'react';

const initialState = { count: 0 };

function reducer(state, action) {
  switch (action.type) {
    case 'increment':
      return { count: state.count + 1 };
    case 'decrement':
      return { count: state.count - 1 };
    default:
      throw new Error();
  }
}

function Counter() {
  const [state, dispatch] = useReducer(reducer, initialState);
  
  return (
    <div>
      <p>Count: {state.count}</p>
      <button onClick={() => dispatch({ type: 'increment' })}>
        +
      </button>
      <button onClick={() => dispatch({ type: 'decrement' })}>
        -
      </button>
    </div>
  );
}
```

### useMemo
```javascript
import React, { useMemo, useState } from 'react';

function ExpensiveComponent({ items }) {
  const [filter, setFilter] = useState('');
  
  const filteredItems = useMemo(() => {
    return items.filter(item => 
      item.name.toLowerCase().includes(filter.toLowerCase())
    );
  }, [items, filter]);
  
  return (
    <div>
      <input 
        value={filter}
        onChange={(e) => setFilter(e.target.value)}
        placeholder="Filter items"
      />
      <ul>
        {filteredItems.map(item => (
          <li key={item.id}>{item.name}</li>
        ))}
      </ul>
    </div>
  );
}
```

### useCallback
```javascript
import React, { useCallback, useState } from 'react';

function Parent() {
  const [count, setCount] = useState(0);
  
  const handleClick = useCallback(() => {
    console.log('Button clicked');
  }, []); // 空依赖数组，函数不会重新创建
  
  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>
        Increment
      </button>
      <Child onClick={handleClick} />
    </div>
  );
}

const Child = React.memo(({ onClick }) => {
  return <button onClick={onClick}>Click me</button>;
});
```

## 自定义 Hooks

### 自定义 Hook 示例
```javascript
import { useState, useEffect } from 'react';

function useLocalStorage(key, initialValue) {
  const [storedValue, setStoredValue] = useState(() => {
    try {
      const item = window.localStorage.getItem(key);
      return item ? JSON.parse(item) : initialValue;
    } catch (error) {
      console.error(error);
      return initialValue;
    }
  });
  
  const setValue = (value) => {
    try {
      setStoredValue(value);
      window.localStorage.setItem(key, JSON.stringify(value));
    } catch (error) {
      console.error(error);
    }
  };
  
  return [storedValue, setValue];
}

// 使用自定义 Hook
function MyComponent() {
  const [name, setName] = useLocalStorage('name', '');
  
  return (
    <input 
      value={name}
      onChange={(e) => setName(e.target.value)}
      placeholder="Enter your name"
    />
  );
}
```

### 网络请求 Hook
```javascript
function useFetch(url) {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  
  useEffect(() => {
    const fetchData = async () => {
      try {
        setLoading(true);
        const response = await fetch(url);
        const result = await response.json();
        setData(result);
      } catch (err) {
        setError(err);
      } finally {
        setLoading(false);
      }
    };
    
    fetchData();
  }, [url]);
  
  return { data, loading, error };
}

// 使用
function UserList() {
  const { data: users, loading, error } = useFetch('/api/users');
  
  if (loading) return <div>Loading...</div>;
  if (error) return <div>Error: {error.message}</div>;
  
  return (
    <ul>
      {users?.map(user => (
        <li key={user.id}>{user.name}</li>
      ))}
    </ul>
  );
}
```

## Hooks 规则

### 1. 只在顶层调用 Hooks
```javascript
// ❌ 错误 - 在条件语句中调用
function MyComponent() {
  if (condition) {
    const [state, setState] = useState(0); // 错误
  }
}

// ✅ 正确 - 在顶层调用
function MyComponent() {
  const [state, setState] = useState(0);
  
  if (condition) {
    // 其他逻辑
  }
}
```

### 2. 只在 React 函数中调用 Hooks
```javascript
// ❌ 错误 - 在普通函数中调用
function regularFunction() {
  const [state, setState] = useState(0); // 错误
}

// ✅ 正确 - 在 React 组件中调用
function MyComponent() {
  const [state, setState] = useState(0); // 正确
}
```

## 性能优化

### 避免不必要的重新渲染
```javascript
// 使用 React.memo
const ExpensiveComponent = React.memo(({ data }) => {
  return <div>{/* 复杂渲染逻辑 */}</div>;
});

// 使用 useMemo 和 useCallback
function OptimizedComponent({ items, onItemClick }) {
  const expensiveValue = useMemo(() => {
    return items.reduce((sum, item) => sum + item.value, 0);
  }, [items]);
  
  const handleClick = useCallback((id) => {
    onItemClick(id);
  }, [onItemClick]);
  
  return (
    <div>
      <p>Total: {expensiveValue}</p>
      {items.map(item => (
        <Item key={item.id} item={item} onClick={handleClick} />
      ))}
    </div>
  );
}
```

## 学习总结

React Hooks 是现代 React 开发的核心特性，掌握 Hooks 能够：

1. **简化组件逻辑**：用函数组件替代类组件
2. **提高代码复用性**：通过自定义 Hooks 共享逻辑
3. **改善开发体验**：更好的 TypeScript 支持和调试体验
4. **优化性能**：通过 useMemo 和 useCallback 避免不必要的计算

建议多练习自定义 Hooks，这是掌握 Hooks 的关键。

---

*最后更新：2019年9月21日*