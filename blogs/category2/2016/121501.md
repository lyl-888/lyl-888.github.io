---
title: 算法学习笔记 - 排序算法
date: 2016/12/15
tags:
  - 算法
  - 排序
  - 数据结构
categories:
  - 算法学习
cover: https://images.unsplash.com/photo-1516321318423-f06f85e504b3?w=800&h=400&fit=crop
---

# 算法学习笔记 - 排序算法

## 排序算法概述

排序算法是计算机科学中最基础也是最重要的算法之一。不同的排序算法有不同的时间复杂度和空间复杂度，适用于不同的场景。

### 常见排序算法分类

1. **比较排序**：通过比较元素大小来排序
2. **非比较排序**：不通过比较元素大小来排序
3. **稳定排序**：相等元素的相对位置不变
4. **不稳定排序**：相等元素的相对位置可能改变

## 冒泡排序 (Bubble Sort)

### 算法思想
重复遍历数组，比较相邻元素，如果顺序错误就交换它们。

### 实现代码
```javascript
function bubbleSort(arr) {
  const n = arr.length;
  
  for (let i = 0; i < n - 1; i++) {
    let swapped = false;
    
    for (let j = 0; j < n - i - 1; j++) {
      if (arr[j] > arr[j + 1]) {
        // 交换元素
        [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
        swapped = true;
      }
    }
    
    // 如果没有发生交换，说明数组已经有序
    if (!swapped) break;
  }
  
  return arr;
}
```

### 复杂度分析
- **时间复杂度**：O(n²) 最坏情况，O(n) 最好情况
- **空间复杂度**：O(1)
- **稳定性**：稳定

## 选择排序 (Selection Sort)

### 算法思想
每次从未排序部分选择最小（或最大）元素，放到已排序部分的末尾。

### 实现代码
```javascript
function selectionSort(arr) {
  const n = arr.length;
  
  for (let i = 0; i < n - 1; i++) {
    let minIndex = i;
    
    // 找到未排序部分的最小元素
    for (let j = i + 1; j < n; j++) {
      if (arr[j] < arr[minIndex]) {
        minIndex = j;
      }
    }
    
    // 交换元素
    if (minIndex !== i) {
      [arr[i], arr[minIndex]] = [arr[minIndex], arr[i]];
    }
  }
  
  return arr;
}
```

### 复杂度分析
- **时间复杂度**：O(n²)
- **空间复杂度**：O(1)
- **稳定性**：不稳定

## 插入排序 (Insertion Sort)

### 算法思想
将数组分为已排序和未排序两部分，每次将未排序部分的第一个元素插入到已排序部分的正确位置。

### 实现代码
```javascript
function insertionSort(arr) {
  const n = arr.length;
  
  for (let i = 1; i < n; i++) {
    const key = arr[i];
    let j = i - 1;
    
    // 将大于 key 的元素向后移动
    while (j >= 0 && arr[j] > key) {
      arr[j + 1] = arr[j];
      j--;
    }
    
    // 插入 key
    arr[j + 1] = key;
  }
  
  return arr;
}
```

### 复杂度分析
- **时间复杂度**：O(n²) 最坏情况，O(n) 最好情况
- **空间复杂度**：O(1)
- **稳定性**：稳定

## 快速排序 (Quick Sort)

### 算法思想
选择一个基准元素，将数组分为小于基准和大于基准的两部分，然后递归排序这两部分。

### 实现代码
```javascript
function quickSort(arr, low = 0, high = arr.length - 1) {
  if (low < high) {
    // 分区操作
    const pivotIndex = partition(arr, low, high);
    
    // 递归排序左半部分
    quickSort(arr, low, pivotIndex - 1);
    
    // 递归排序右半部分
    quickSort(arr, pivotIndex + 1, high);
  }
  
  return arr;
}

function partition(arr, low, high) {
  const pivot = arr[high];
  let i = low - 1;
  
  for (let j = low; j < high; j++) {
    if (arr[j] <= pivot) {
      i++;
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
  }
  
  [arr[i + 1], arr[high]] = [arr[high], arr[i + 1]];
  return i + 1;
}
```

### 复杂度分析
- **时间复杂度**：O(n log n) 平均情况，O(n²) 最坏情况
- **空间复杂度**：O(log n) 平均情况，O(n) 最坏情况
- **稳定性**：不稳定

## 归并排序 (Merge Sort)

### 算法思想
将数组递归地分成两半，分别排序，然后合并两个有序数组。

### 实现代码
```javascript
function mergeSort(arr) {
  if (arr.length <= 1) {
    return arr;
  }
  
  const mid = Math.floor(arr.length / 2);
  const left = mergeSort(arr.slice(0, mid));
  const right = mergeSort(arr.slice(mid));
  
  return merge(left, right);
}

function merge(left, right) {
  const result = [];
  let i = 0, j = 0;
  
  while (i < left.length && j < right.length) {
    if (left[i] <= right[j]) {
      result.push(left[i]);
      i++;
    } else {
      result.push(right[j]);
      j++;
    }
  }
  
  return result.concat(left.slice(i)).concat(right.slice(j));
}
```

### 复杂度分析
- **时间复杂度**：O(n log n)
- **空间复杂度**：O(n)
- **稳定性**：稳定

## 堆排序 (Heap Sort)

### 算法思想
利用堆这种数据结构的性质，将数组构建成最大堆，然后依次取出堆顶元素。

### 实现代码
```javascript
function heapSort(arr) {
  const n = arr.length;
  
  // 构建最大堆
  for (let i = Math.floor(n / 2) - 1; i >= 0; i--) {
    heapify(arr, n, i);
  }
  
  // 依次取出堆顶元素
  for (let i = n - 1; i > 0; i--) {
    [arr[0], arr[i]] = [arr[i], arr[0]];
    heapify(arr, i, 0);
  }
  
  return arr;
}

function heapify(arr, n, i) {
  let largest = i;
  const left = 2 * i + 1;
  const right = 2 * i + 2;
  
  if (left < n && arr[left] > arr[largest]) {
    largest = left;
  }
  
  if (right < n && arr[right] > arr[largest]) {
    largest = right;
  }
  
  if (largest !== i) {
    [arr[i], arr[largest]] = [arr[largest], arr[i]];
    heapify(arr, n, largest);
  }
}
```

### 复杂度分析
- **时间复杂度**：O(n log n)
- **空间复杂度**：O(1)
- **稳定性**：不稳定

## 算法比较

| 算法 | 时间复杂度 | 空间复杂度 | 稳定性 | 适用场景 |
|------|------------|------------|--------|----------|
| 冒泡排序 | O(n²) | O(1) | 稳定 | 小规模数据，教学 |
| 选择排序 | O(n²) | O(1) | 不稳定 | 小规模数据 |
| 插入排序 | O(n²) | O(1) | 稳定 | 小规模数据，部分有序 |
| 快速排序 | O(n log n) | O(log n) | 不稳定 | 大规模数据，通用 |
| 归并排序 | O(n log n) | O(n) | 稳定 | 大规模数据，稳定排序 |
| 堆排序 | O(n log n) | O(1) | 不稳定 | 大规模数据，内存受限 |

## 实际应用建议

1. **小规模数据（< 50）**：插入排序或选择排序
2. **中等规模数据（50-1000）**：快速排序或归并排序
3. **大规模数据（> 1000）**：快速排序、归并排序或堆排序
4. **需要稳定排序**：归并排序
5. **内存受限**：堆排序

## 学习总结

排序算法是算法学习的基础，掌握这些算法有助于：

1. **理解算法思想**：分治、递归、贪心等
2. **分析复杂度**：时间和空间复杂度的计算
3. **选择合适算法**：根据场景选择最优算法
4. **提高编程能力**：实现复杂逻辑的能力

建议多动手实现这些算法，理解其原理和适用场景。

---

*最后更新：2016年12月15日*